using MCSharp.Cmds;
using MCSharp.Exception;
using MCSharp.Type;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;

namespace MCSharp
{
    public class Datapack
    {
        /// <summary>
        /// 数据包输出路径
        /// </summary>
        public static string outputPath = "./";

        /// <summary>
        /// 数据包版本
        /// </summary>
        public static int version;

        /// <summary>
        /// 数据包描述
        /// </summary>
        //public static JsonText discription = new JsonText("A datapack generated by MCSharp");
        public static string discription = "A datapack generated by MCSharp";

        /// <summary>
        /// 数据包名字
        /// </summary>
        public static string name = "Unnamed";

        /// <summary>
        /// 数据包中的所有函数
        /// </summary>
        public static Dictionary<string, Function> functions = new Dictionary<string, Function>();

        public new static string ToString()
        {
            return name;
        }

        /// <summary>
        /// 创建一个数据包
        /// </summary>
        public static void Create()
        {
            //删除旧数据包
            DirectoryInfo old = new DirectoryInfo(outputPath + "\\" + name);
            if (old.Exists)
            {
                old.Delete(true);
            }
            //生成数据包
            DirectoryInfo func = Directory.CreateDirectory(outputPath + "\\" + name + "\\data\\qwq\\functions");
            foreach (KeyValuePair<string, Function> function in functions)
            {
                //生成函数文件
                StreamWriter fs = new StreamWriter(File.Create(func.FullName + "\\" + function.Value.name + ".mcfunction"));
                StringBuilder builder = new StringBuilder();
                foreach (var commands in function.Value.GetCommands())
                {
                    builder.Append(commands.ToString()).AppendLine();
                }
                fs.Write(builder);
                fs.Flush();
                fs.Close();
            }
            File.WriteAllText(outputPath + "\\" + name + "\\pack.mcmeta", "{\r\n    \"pack\": {\r\n        \"description\":\"" + discription + "\",\r\n        \"pack_format\": 10\r\n    }\r\n}");
        }

        /// <summary>
        /// 清空数据包
        /// </summary>
        public static void Clear()
        {
            functions = new Dictionary<string, Function>();
            outputPath = "./";
            name = "Unnamed";
            version = 10;
            discription = "A datapack generated by MCSharp";
        }

        /// <summary>
        /// 创建数据包并清理数据包
        /// </summary>
        public static void CreateAndClear()
        {
            Create();
            Clear();
        }

        /// <summary>
        /// 注册一个函数为命令函数到数据包中
        /// </summary>
        public static void RegistryFunction()
        {
            StackFrame sf = new StackTrace().GetFrame(1);
            string funcname = sf.GetMethod().DeclaringType.FullName + "$" + sf.GetMethod().Name;
            Function n = new Function(funcname);
            //若函数没用被注册，则注册此函数
            if (!functions.ContainsKey(funcname))
            {
                functions.Add(funcname, n);
            }
        }

        /// <summary>
        /// 此数据包中是否含有此函数
        /// </summary>
        /// <param name="stackName">函数在栈中的名字</param>
        /// <returns>如果含有此函数返回true</returns>
        public static bool HasFunction(string stackName)
        {
            foreach (string names in functions.Keys)
            {
                if (names.Equals(stackName))
                {
                    return true;
                }
            }
            return false;
        }

        //TODO:debug用函数
        public static void PrintFunctionNames()
        {
            StringBuilder stringBuilder = new StringBuilder("");
            foreach (Function function in functions.Values)
            {
                stringBuilder.Append(function).AppendLine();
            }
            Console.Write(stringBuilder.ToString());
        } 
    }
}