using MCSharp.Cmds;
using MCSharp.Exception;
using MCSharp.Type;
using MCSharp.Util;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;

namespace MCSharp
{
    public class DatapackInfo
    {
        /// <summary>
        /// 数据包输出路径，应该是一个datapack文件夹下
        /// </summary>
        public static string outputPath = "./";

        /// <summary>
        /// 数据包版本
        /// </summary>
        public static int version;

        /// <summary>
        /// 数据包描述
        /// </summary>
        //public static JsonText discription = new JsonText("A datapack generated by MCSharp");
        public static string discription = "A datapack generated by MCSharp";

        /// <summary>
        /// 数据包名字
        /// </summary>
        public static string name = "Unnamed";

        /// <summary>
        /// 数据包中的所有函数
        /// </summary>
        public static Dictionary<string, FunctionInfo> functions = new Dictionary<string, FunctionInfo>();

        /// <summary>
        /// 数据包的编译日志
        /// </summary>
        public static Log log = new Log();

        public new static string ToString()
        {
            return name;
        }

        /// <summary>
        /// 创建一个数据包
        /// </summary>
        public static void Create()
        {
            //删除旧数据包
            DirectoryInfo old = new DirectoryInfo(outputPath + "\\" + name);
            if (old.Exists)
            {
                old.Delete(true);
            }
            //生成数据包
            DirectoryInfo func = Directory.CreateDirectory(outputPath + "\\" + name);
            foreach (KeyValuePair<string, FunctionInfo> function in functions)
            {
                //生成函数文件的路径
                DirectoryInfo di = new DirectoryInfo(func.FullName + "\\data\\"+ function.Value.@namespace +"\\functions\\" + function.Value.path.Substring(0, function.Value.path.LastIndexOf('/')));
                if (!di.Exists)
                {
                    di.Create();
                }
                //生成函数文件
                StreamWriter fs = new StreamWriter(File.Create(di.FullName + "\\" + function.Value.name + ".mcfunction"));
                StringBuilder builder = new StringBuilder();
                foreach (var commands in function.Value.GetCommands())
                {
                    builder.Append(commands.ToString()).AppendLine();
                }
                fs.Write(builder);
                fs.Flush();
                fs.Close();
            }
            File.WriteAllText(outputPath + "\\" + name + "\\pack.mcmeta", "{\r\n    \"pack\": {\r\n        \"description\":\"" + discription + "\",\r\n        \"pack_format\": " + version + "\r\n    }\r\n}");
        }

        /// <summary>
        /// 清空数据包
        /// </summary>
        public static void Clear()
        {
            functions = new Dictionary<string, FunctionInfo>();
            outputPath = "./";
            name = "Unnamed";
            version = 10;
            discription = "A datapack generated by MCSharp";
            log = new Log();
        }

        /// <summary>
        /// 创建数据包并清理数据包
        /// </summary>
        public static void CreateAndClear()
        {
            Create();
            Clear();
        }

        /// <summary>
        /// 注册一个函数为命令函数到数据包中
        /// </summary>
        public static void RegistryFunction()
        {
            StackFrame sf = new StackTrace().GetFrame(1);
            string funcname = sf.GetMethod().DeclaringType.Namespace + "$" + sf.GetMethod().DeclaringType.Name + "$" + sf.GetMethod().Name;
            FunctionInfo n = new FunctionInfo(funcname);
            //若函数没用被注册，则注册此函数
            if (!functions.ContainsKey(funcname))
            {
                functions.Add(funcname, n);
            }
        }

        /// <summary>
        /// 此数据包中是否含有此函数
        /// </summary>
        /// <param name="stackName">函数在栈中的名字</param>
        /// <returns>如果含有此函数返回true</returns>
        public static bool HasFunction(string stackName)
        {
            foreach (string names in functions.Keys)
            {
                if (names.Equals(stackName))
                {
                    return true;
                }
            }
            return false;
        }

        //TODO:debug用函数
        public static void PrintFunctionNames()
        {
            StringBuilder stringBuilder = new StringBuilder("");
            foreach (FunctionInfo function in functions.Values)
            {
                stringBuilder.Append(function).AppendLine();
            }
            Console.Write(stringBuilder.ToString());
        }

        /// <summary>
        /// 此命令函数是否被注册
        /// </summary>
        /// <returns>如果命令函数被注册，返回true</returns>
        public static bool FunctionHasRegistry()
        {
            StackFrame s = new StackFrame(2);
            if (DatapackInfo.functions.ContainsKey(s.GetMethod().DeclaringType.Namespace + "$" + s.GetMethod().DeclaringType.Name + "$" + s.GetMethod().Name))
            {
                return true;
            }
            return false;
        }
    }
}