# MCSharp（MC#）
该项目旨在让开发者可以利用C#的方式进行数据包开发，并利用C#中的诸多特性协助数据包的开放 

此项目处于起步阶段，目前已经搭建完毕函数的编程。正在将Minecraft中基础的命令以类和函数的形式写入C#中以供调用

## 计划单
* 函数编程框架搭建（已完成）
* 基本命令C#化（正在进行）
* 记分板操作（计划中）
* 实体与nbt操作（计划中）
* 原始JSON文本（计划中）
* ...

## 简单例子
在MC#中，一个命令函数是由C#中的一个静态函数定义的。并且，在此静态函数中调用命令之前，必须使用`DatapackInfo.RegistryFunction()`函数对此函数进行注册。

命令函数对应命名转换规则是，C#函数所在类的命名空间为命令函数命名空间，而类则为存放命令函数的文件夹，函数的名字则是命令函数的名字。值得注意的是，这些名字仍然需要符合Minecraft对数据包中函数命名空间的要求，即只能包含字母数字和下划线。在转换时，会自动将原函数的命名空间，类，名字等的大写字母自动转换为小写。

下面是一个简单的实例程序。它展示了C#中创建一个数据包的基本操作，并且展示了MC#的基本编程逻辑。

```C#
using MCSharp.Cmds;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MCSharp.Test
{
    internal class Test
    {
        public static void Main(string[] args)
        {
            DatapackInfo.name = "qwq";  //数据包名字
            DatapackInfo.discription = "A datapack generated by MCSharp";   //数据包描述
            DatapackInfo.outputPath = "D:\\.minecraft\\saves\\Datapack Lab\\datapacks";   //数据包路径
            start();    //一个功能的入口
            //Commands.Say("qwq");      //不能直接在主函数中使用命令
            DatapackInfo.Create();      //生成数据包
        }

        public static void start()
        {
            //Commands.Say("qwq");  //函数未注册，不能使用命令
            //一个函数
            DatapackInfo.RegistryFunction();    //注册此函数为命令函数，可以在函数中使用命令
            Commands.Say("start!"); //命令say start!
            test1();
            test2();    //函数的调用
        }

        public static void test1()
        {
            DatapackInfo.RegistryFunction();
            Commands.Say("test1");
            test2();    //函数的调用
        }

        public static void test2()
        {
            DatapackInfo.RegistryFunction();
            Commands.Say("test2");
        }
    }
}
```
你可能会注意到，在Main函数中并不能直接调用命令，而是需要一个称作功能函数入口的东西调用一个函数，在函数中执行。

这样的逻辑是，在数据包中，它每实现一个功能，要使用这个功能时，必定会调用一个根函数。这个函数可能是玩家手动调用，也可能是tick或者load这样由游戏调用的函数，再以这个根函数调用其他的函数，从而实现完整的功能。功能函数入口的概念就来源于此，Main函数中相当于定义了无数个数据包的功能，而功能的具体实现则在它调用的函数中。
